-- find all root nodes
select a.name, a.id from account_parents ap
join accounts a on a.id = ap.account_id
where ap.parent_id is null


-- find direct children (1 level down) for each root
select a.name, p.name as parent from account_parents ap
join accounts a on a.id = ap.account_id
join accounts p on p.id = ap.parent_id
where ap.parent_id in (
  -- find parent nodes
	select  a.id from account_parents ap
	join accounts a on a.id = ap.account_id
	where ap.parent_id is null
)




-- find entire hierarchy of all root nodes
WITH RECURSIVE cte AS
(
  -- # seed SELECT
  SELECT account_id, parent_id FROM account_parents WHERE parent_id IS NULL
  UNION ALL
  -- # recursive SELECT
  SELECT c.account_id, c.parent_id FROM account_parents c 
  JOIN cte ON cte.account_id=c.parent_id --  # find children
)
SELECT a.name, p.name as parent FROM cte
join accounts a on a.id = cte.account_id
join accounts p on p.id = cte.parent_id



-- find entire hierarchy of a specific root node (id 1)
WITH RECURSIVE cte AS
(
  -- # seed SELECT
  SELECT account_id, parent_id FROM account_parents WHERE parent_id = 1
  UNION ALL
  -- # recursive SELECT
  SELECT c.account_id, c.parent_id FROM account_parents c 
  JOIN cte ON cte.account_id=c.parent_id --  # find children
)
SELECT a.name, p.name as parent, a.id, p.id FROM cte
join accounts a on a.id = cte.account_id
join accounts p on p.id = cte.parent_id





-- find entire hierarchy of a specific root node (id 1) with depth of nodes
WITH RECURSIVE cte AS
(
  -- # seed SELECT
  SELECT account_id, parent_id, 0 as depth FROM account_parents WHERE parent_id = 1
  UNION ALL
  -- # recursive SELECT
  SELECT c.account_id, c.parent_id,cte.depth + 1 FROM account_parents c 
  JOIN cte ON cte.account_id=c.parent_id --  # find children
)
SELECT a.name, p.name as parent, a.id, p.id, cte.depth FROM cte
join accounts a on a.id = cte.account_id
join accounts p on p.id = cte.parent_id





-- find entire hierarchy of a specific root node (id 1) with depth of nodes and path of hierarchy
WITH RECURSIVE cte AS
(
  -- # seed SELECT
  SELECT account_id, parent_id, 0 as depth, CAST(account_id AS CHAR(200)) as path FROM account_parents WHERE parent_id = 1
  UNION ALL
  -- # recursive SELECT
  SELECT c.account_id, c.parent_id,cte.depth + 1, CONCAT(cte.path, ",", c.account_id) FROM account_parents c 
  JOIN cte ON cte.account_id=c.parent_id --  # find children
)
SELECT a.name, p.name as parent, a.id, p.id, cte.depth, cte.path FROM cte
join accounts a on a.id = cte.account_id
join accounts p on p.id = cte.parent_id




-- find entire hierarchy of a specific root node (id 1) with depth of nodes and path of hierarchy with account names
WITH RECURSIVE cte AS
(
  -- # seed SELECT
  SELECT account_id, parent_id, 0 as depth, CAST(a.name AS CHAR(200)) as path FROM account_parents 
  join accounts a on a.id = account_id
  WHERE parent_id is null

  UNION ALL

  -- # recursive SELECT
  SELECT c.account_id, c.parent_id,cte.depth + 1, CONCAT(cte.path, ",", a.name) FROM account_parents c 
  join accounts a on a.id = c.account_id
   JOIN cte ON cte.account_id=c.parent_id --  # find children
)

SELECT a.name, p.name as parent, cte.path, cte.account_id, cte.parent_id FROM cte
join accounts a on a.id = cte.account_id
left join accounts p on p.id = cte.parent_id

-- outputs
a1		a1	1	
a2		a2	2	
a3		a3	3	
a4		a4	4	
b1	a1	a1,b1	5	1
b4	a1	a1,b4	8	1
e1	a1	a1,e1	24	1
b3	a1	a1,b3	7	1
b2	a2	a2,b2	6	2
b5	a3	a3,b5	9	3




-- find leaf nodes for a given node. Leaf nodes = those account ids that are not parents of other nodes

WITH RECURSIVE cte AS
(
  -- # seed SELECT
  SELECT account_id, parent_id, 0 as depth, CAST(a.name AS CHAR(200)) as path FROM account_parents 
  join accounts a on a.id = account_id
  WHERE parent_id = 2

  UNION ALL

  -- # recursive SELECT
  SELECT c.account_id, c.parent_id,cte.depth + 1, CONCAT(cte.path, ",", a.name) FROM account_parents c 
  join accounts a on a.id = c.account_id
   JOIN cte ON cte.account_id=c.parent_id --  # find children
)

SELECT a.name, p.name as parent, cte.depth, cte.path, cte.account_id, cte.parent_id FROM cte
join accounts a on a.id = cte.account_id
left join accounts p on p.id = cte.parent_id
-- now find which nodes are not a parent to others
-- this seems very inefficient as it looks across an entire table
where cte.account_id  
not in (
select distinct parent_id from account_parents where parent_id is not null
)




-- given a node, find all of its parent nodes
WITH RECURSIVE cte AS
(
  -- # seed SELECT
  SELECT account_id, parent_id, 0 as depth, CAST(a.name AS CHAR(200)) as path, CAST(a.id AS CHAR(200)) as path_ids FROM account_parents 
  join accounts a on a.id = account_id
  WHERE account_id  = 19 -- 19 = d3

  UNION ALL

  -- # recursive SELECT
  SELECT c.account_id, c.parent_id, cte.depth - 1, CONCAT(cte.path, ",", a.name) , CONCAT(cte.path_ids, ",", a.id)FROM account_parents c 
  join accounts a on a.id = c.account_id
   JOIN cte ON c.account_id=cte.parent_id --  # find children
)

SELECT a.name, p.name as parent, cte.depth, cte.path, cte.path_ids, cte.account_id, cte.parent_id FROM cte
join accounts a on a.id = cte.account_id
left join accounts p on p.id = cte.parent_id

-- returns
d3	c4	0	d3	19	19	14
c4	b3	-1	d3,c4	19,14	14	7
b3	a1	-2	d3,c4,b3	19,14,7	7	1
b3	a3	-2	d3,c4,b3	19,14,7	7	3
a1		-3	d3,c4,b3,a1	19,14,7,1	1	
a3		-3	d3,c4,b3,a3	19,14,7,3	3	






-- given a node, find all of its child nodes
WITH RECURSIVE cte AS
(
  -- # seed SELECT
  SELECT account_id, parent_id, 0 as depth, CAST(a.name AS CHAR(200)) as path, CAST(a.id AS CHAR(200)) as path_ids FROM account_parents 
  join accounts a on a.id = account_id
  WHERE account_id  = 21 -- 21 = d5

  UNION ALL

  -- # recursive SELECT
  SELECT c.account_id, c.parent_id, cte.depth + 1, CONCAT(cte.path, ",", a.name) , CONCAT(cte.path_ids, ",", a.id)FROM account_parents c 
  join accounts a on a.id = c.account_id
   JOIN cte ON c.parent_id=cte.account_id --  # find children
)

SELECT a.name, p.name as parent, cte.depth, cte.path, cte.path_ids, cte.account_id, cte.parent_id FROM cte
join accounts a on a.id = cte.account_id
left join accounts p on p.id = cte.parent_id

-- returns
d5	c5	0	d5	21	21	15
e1	d5	1	d5,e1	21,24	24	21
e2	d5	1	d5,e2	21,25	25	21
f1	e1	2	d5,e1,f1	21,24,27	27	24
f2	e2	2	d5,e2,f2	21,25,28	28	25
g1	f2	3	d5,e2,f2,g1	21,25,28,29	29	28
h1	g1	4	d5,e2,f2,g1,h1	21,25,28,29,30	30	29






-- given a node, find all of its immediate child nodes (having a depth of 0)
WITH RECURSIVE cte AS
(
  -- # seed SELECT
  SELECT account_id, parent_id, 0 as depth, CAST(a.name AS CHAR(200)) as path, CAST(a.id AS CHAR(200)) as path_ids FROM account_parents 
  join accounts a on a.id = account_id
  WHERE account_id  = 21 -- 21 = d5

  UNION ALL

  -- # recursive SELECT
  SELECT c.account_id, c.parent_id, cte.depth + 1, CONCAT(cte.path, ",", a.name) , CONCAT(cte.path_ids, ",", a.id)FROM account_parents c 
  join accounts a on a.id = c.account_id
   JOIN cte ON c.parent_id=cte.account_id --  # find children
   where depth = 0
)

SELECT a.name, p.name as parent, cte.depth, cte.path, cte.path_ids, cte.account_id, cte.parent_id FROM cte
join accounts a on a.id = cte.account_id
left join accounts p on p.id = cte.parent_id

-- returns 
d5	c5	0	d5	21	21	15
e1	d5	1	d5,e1	21,24	24	21
e2	d5	1	d5,e2	21,25	25	21





-- given a node, show the number of nodes at each level
select depth, count(*) as node_count
from (

WITH RECURSIVE cte AS
(
  -- # seed SELECT
  SELECT account_id, parent_id, 0 as depth, CAST(a.name AS CHAR(200)) as path FROM account_parents 
  join accounts a on a.id = account_id
  WHERE parent_id = 1

  UNION ALL

  -- # recursive SELECT
  SELECT c.account_id, c.parent_id,cte.depth + 1, CONCAT(cte.path, ",", a.name) FROM account_parents c 
  join accounts a on a.id = c.account_id
   JOIN cte ON cte.account_id=c.parent_id --  # find children
)

-- SELECT distinct depth,  cte.accoun t_id FROM cte
SELECT  depth FROM cte
join accounts a on a.id = cte.account_id
left join accounts p on p.id = cte.parent_id
group by account_id, depth

)x group by x.depth


-- returns
depth, count
0	4
1	6
2	7
3	3
4	2
5	1
6	1


-- maybe other questions
given a node, what other immediate siblings belong to the same parent node.

moving a node, just requires
1. delete existing rows where parent is old parent
2. add row with new parent id
children remain uneffected

